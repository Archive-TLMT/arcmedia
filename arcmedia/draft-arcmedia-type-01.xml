<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.25 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-arcmedia-type-01" category="info">

  <front>
    <title abbrev="arcmedia">The Archive Primary Media Type for File Archives</title>

    <author initials="S." surname="Leonard" fullname="Sean Leonard">
      <organization>Penango, Inc.</organization>
      <address>
        <postal>
          <street>5900 Wilshire Boulevard</street> <street>21st Floor</street>
          <city>Los Angeles</city>
          <region>CA</region>
          <code>90036</code>
          <country>USA</country>
        </postal>
        <email>dev+ietf@seantek.com</email>
        <uri>http://www.penango.com/</uri>
      </address>
    </author>
    <author initials="M." surname="Kerwin" fullname="Matthew Kerwin">
      <organization></organization>
      <address>
        <email>matthew@kerwin.net.au</email>
        <uri>http://matthew.kerwin.net.au/</uri>
      </address>
    </author>

    <date year="2015"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines a new primary content-type to be known as
“archive”, which defines a fundamental type of content with unique
presentational, hardware, and processing aspects.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The purpose of this memo is to propose an update to <xref target="RFC2045"/> to
include a new primary content-type to be known as “archive”.
<xref target="RFC2045"/> describes mechanisms for specifying and describing the
format of Internet Message Bodies via content-type/subtype pairs.
“archive” defines a fundamental type of content with unique
presentational, hardware, and processing aspects.  Various subtypes
of this primary type are immediately anticipated, and will be covered
under separate documents.</t>

<section anchor="overview" title="Overview">

<t>This document will outline what an archive is, show examples of
archives, and discuss the benefits of grouping archives together.</t>

<t>This document is a discussion document for an agreed definition,
intended eventually to form a standard accepted extension to
<xref target="RFC2045"/>.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
</section>
<section anchor="definition" title="Definition of an archive">

<t>An archive primary media type identifies data that represents one or
more files [cite] along with metadata.  Archives are used to collect
multiple data files together into a single file for easier
portability and storage. Archive formats can provide many optional
services, including:</t>

<t><list style="numbers">
  <t>compression</t>
  <t>encryption</t>
  <t>authentication</t>
  <t>backup</t>
  <t>filesystem imaging</t>
  <t>software packaging and distribution</t>
  <t>volume-splitting (archive split into multiple contents)</t>
  <t>block storage</t>
</list></t>

<t>Formats and techniques that perform one or more of these services
already exist under separate registrations. For example, the Content-
Encoding header can be used to compress Internet message content. The
distinguishing feature of the archive primary type is that these
services are integrated into the format itself, along with the
inclusion of file-specific metadata. Virtually all formats
contemplated under this primary type are designed to concatenate
multiple files into a single data stream, along with filenames and
other metadata. When an Internet-facing application handles content
labeled with this type, it SHOULD provide handling consistent with
the archive as a discrete data item. For example, an Internet mail
user agent would display an archive-labeled type with an archive
icon, possibly with a preview of the files contained therein (as
opposed to automatically traversing its contents, as it would for
multipart-labeled content).</t>

<t>Common operations include creating an archive, identifying files in
an archive, adding to an archive, backing up to an archive,
extracting an archive, restoring from an archive, deleting from an
archive, mounting and unmounting an archive, [[TODO: executing an
archive?]], and installing and uninstalling an archive.</t>

<t><list style="symbols">
  <t>Creating: taking files from a filesystem and representing those
   files in an archive.</t>
  <t>Identifying files: parsing an archive’s format, extracting
   information about files represented in the archive.</t>
  <t>Adding: parsing an archive’s format, adding files or non-file data
   to the archive. In virtually all cases, at least some part of
   the archive’s content will be modified (though perhaps only at
   the end). Unlike, for instance, text media types, concatenating
   two separate archive contents <spanx style="emph">never</spanx> yields a valid composite
   archive.</t>
  <t>Backing up: taking some or all of a filesystem and representing the
   filesystem in an archive, with the express intention of
   recording the files as they exist in a source filesystem at the
   time of backing up. For example, the compression, encryption,
   and access control list (permissions) properties of the files
   would be preserved.</t>
  <t>Extracting: parsing an archive’s format, copying file data (or file
   metadata) out of the archive into one or more files on a
   destination filesystem. This operation implies that at least
   some file metadata will be preserved, while other file metadata
   may be adjusted or added to adapt to the local environment.</t>
  <t>Restoring: parsing an archive’s format, copying file data out of
   the archive into the destination filesystem, with the express
   intention of recreating the files as they existed in a source
   filesystem at the time of backing up. For example, the
   compression, encryption, and access control list (permissions)
   properties of the files would be preserved.</t>
  <t>Deleting: parsing an archive’s format, removing file data (or
   metadata) from the archive, requiring changes to the archive’s
   contents. Some archive formats permit orphan data in the archive
   content; other formats require re-serializing some or all of the
   archive.</t>
  <t>Mounting and unmounting: Mapping an archive’s semantics directly to
   a filesystem, so that the files represented in the archive can
   be accessed using the filesystem’s namespace with typical
   filesystem APIs. Rather than being backed by a physical block
   storage device, that part of the filesystem is backed by the
   archive.</t>
  <t>Executing [[NB: this may be controversial; it is worth
   discussing]]: Identifying executable semantics of an archive,
   and causing code to execute.</t>
  <t>Installing and uninstalling [[NB: this may be controversial; it is
   worth discussing]]: Treating the archive as a software package,
   extracting certain contents in the archive and executing other
   contents in the archive, according to some software packaging
   protocol.</t>
</list></t>

</section>
<section anchor="consultation" title="Consultation Mechanisms">

<t>Before proposing a subtype for the archive/* primary type, it is
suggested that the subtype author examine the definition (above) of
what an archive/* is and the listing (below) of what an archive/* is
not.  Additional consultations with the authors of the existing
archive/* subtypes is also suggested.</t>

</section>
<section anchor="encoding" title="Encoding and Transport">

<t>Unrecognized subtypes of archive SHOULD at a minimum be treated as
“archive/file”.  Like “application/octet-stream”, the purpose of the
“archive/file” is to provide default handling; it does not represent
a particular archive format. Implementations SHOULD pass subtypes of
archive that they do not specifically recognize to a robust
general-purpose archive viewing application, if such an application
is available.</t>

<t>If default archive (archive/file) handling is not supported, it is
appropriate to treat the archive like “application/octet-stream”.</t>

<t>Unless noted in the subtype registration, subtypes of archive SHALL
be assumed to contain binary data, implying a content encoding of
base64 for email and binary transfer for ftp and http.</t>

<t>The formal syntax for the subtypes of the model primary type SHOULD
look like this:</t>

<t><list style='empty'>
  <t><list style="hanging">
    <t hangText='Type name:'><vspace blankLines='0'/>
    archive</t>
    <t hangText='Subtype name:'><vspace blankLines='0'/>
    xxxxxxxx</t>
    <t hangText='Required parameters:'><vspace blankLines='0'/>
    none</t>
    <t hangText='Optional parameters:'><vspace blankLines='0'/>
    TBD</t>
    <t hangText='Encoding considerations:'><vspace blankLines='0'/>
    base64 encoding is recommended when transmitting archive/* documents
 through MIME electronic mail.</t>
    <t hangText='Security considerations:'><vspace blankLines='0'/>
    see <xref target="security"/> below</t>
    <t hangText='Published specification:'><vspace blankLines='0'/>
    TBD</t>
    <t hangText='Applications that use this media type:'><vspace blankLines='0'/>
    TBD</t>
    <t hangText='Fragment identifier considerations:'><vspace blankLines='0'/>
    The considerations of this document, plus any extra syntaxes
 not inconsistent with this document.</t>
    <t hangText='Additional information:'><vspace blankLines='0'/>
            <list style="hanging">
          <t hangText='Deprecated alias names for this type:'>
          (Include non-archive alias names, such as those in application.)</t>
        </list>
    </t>
    <t>Magic number(s): TBD</t>
    <t>File extension(s): TBD</t>
    <t>Macintosh file type code(s): TBD</t>
  </list></t>

  <t>See <xref target="subtypes"/> for references to some of the expected subtypes.</t>

  <t><list style="hanging">
    <t hangText='Person and email address to contact for further information:'><vspace blankLines='0'/>
    TBD</t>
    <t hangText='Intended usage:'><vspace blankLines='0'/>
    TBD (COMMON will be the most common)</t>
    <t hangText='Restrictions on usage:'><vspace blankLines='0'/>
    TBD</t>
    <t hangText='Author:'><vspace blankLines='0'/>
    TBD</t>
    <t hangText='Change controller:'><vspace blankLines='0'/>
    TBD</t>
    <t hangText='Provisional registration? (standards tree only):'><vspace blankLines='0'/>
    (Yes/No)</t>
  </list></t>

  <t>(Any other information that the author deems interesting may be
added below this line.)</t>
</list></t>

<t>The optional parameters consist of starting conditions and variable
values used as part of the subtypes.</t>

</section>
<section anchor="parameters" title="Common Required and Optional Parameters">

<t>Unlike the text primary media type (for instance), virtually all
archive formats have been designed with almost all of the information
required for interpretation contained within the format. Therefore,
parameters are NOT RECOMMENDED; registrants are not expected to
register additional parameters.</t>

<t>Regrettably, not all archive formats are as “universal” or “complete”
as one might assume at first glance. This is because some archive
formats are very old or are based on older formats where backwards-
compatibility was a design goal; thus they were not designed with
transport across the Internet in mind. The ZIP file is an example:
although the modern ZIP supports Unicode [CITE], the default encoding
of ZIP filenames has always been Code Page 437. Since “archive”
contents are literally archives of computing history, sometimes
communicating the archive as-is, rather than updating the archive to
a more universal format, is necessary.</t>

<t>Implementations that are archive-type aware MUST support the
following parameters for maximum compatibility. At the same time, new
archives SHOULD NOT rely on these parameters for disambiguation; new
archives SHOULD be created in such a way that “universal”
interoperability is achieved with the archive’s self-contained
information. [[TODO: code page–it’s like charset but only applies to
certain strings in the archive, when the archive format is ambiguous;
do NOT attempt to apply this parameter as one would apply charset to
text/*. Endian-ness? Time/Y2K representation issues? Anything else?]]</t>

</section>
<section anchor="splitarchives" title="Split Archives">

<t>Several archive formats (notably RAR and ZIP) support split archives.
A “split archive” is an archive that is stored in multiple files
(when stored as multiple files), or more generally, across multiple
storage media.</t>

<t>The ZIP format, for example, actually has two types of splits: “split
archive” and “spanned archive”. A “split archive” is a standard ZIP
archive split over multiple files with the file extensions .z01,
.z02, etc.; the .zip file is the last file. A “spanned archive” is
the original format designed for use with swapping floppy disks. All
archive files have the same filename; the format uses volume labels
(presumably on floppy disks) to store disk numbers. Neither sub-
format is merely a naive division of the octet stream: each ZIP file
is parseable in its own right, and contains its own offset values.</t>

<t>The TAR format (or family of formats, including cpio and ustar) was
originally designed for streaming to and from tape devices, so
splitting is accomplished differently.</t>

<t>[[TODO: Consider how to label this content. archive/zip^01?
archive/zip; split=01? Something else? How shall 01 be associated
with 02, 03, etc., when the Content-Disposition: ; filename=””
parameter is “presentation-information” and may be separated from the
Content-Type header information?]]</t>

</section>
<section anchor="fragments" title="Fragment Identifier Syntax">

<t>Because all archives represent files, archives can serve as virtual
filesystems. Respondents have noted that an archive’s files can be
addressed by a fragment syntax that resembles a filesystem path. At
the same time, archives may record files in different ways (along
with different types of metadata), suggesting that a common baseline
with flexible extension points is more appropriate than a fixed
universal syntax. [[TODO: This will be explored in future drafts.
Note the similarities with this and the file: URI…]]</t>

<t>[[TODO: consider how to provide a fragment for content in the
archive. NB: most archives do NOT provide Content-Type/media type
information! So /foo.html being an HTML file is just an <spanx style="emph">assumption</spanx>,
and possibly a very wrong one at that. There is no IETF registry for
file extensions.]]</t>

</section>
<section anchor="piped-composite-type-suffix-syntax" title="Piped-Composite Type Suffix Syntax">

<t>[[TODO: discuss tar piped through bzip2, gzip, etc. as a distinct
file format, rather than an application of the Content-Encoding:
header. Suggest common suffix like archive/tar|bzip2, where | is some
useful character but not + since + is for structured syntaxes.]]</t>

</section>
<section anchor="security" title="Security Considerations">

<t>Archives represent files, file metadata, and filesystems; thus,
security issues loom large because archives can contain just about
anything. These concerns are magnified by the arbitrary transport of
such data across the Internet. [[TODO: complete.]]</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2045'>

<front>
<title abbrev='Internet Message Bodies'>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
<author initials='N.' surname='Freed' fullname='Ned Freed'>
<organization>Innosoft International, Inc.</organization>
<address>
<postal>
<street>1050 East Garvey Avenue South</street>
<city>West Covina</city>
<region>CA</region>
<code>91790</code>
<country>US</country></postal>
<phone>+1 818 919 3600</phone>
<facsimile>+1 818 919 3614</facsimile>
<email>ned@innosoft.com</email></address></author>
<author initials='N.S.' surname='Borenstein' fullname='Nathaniel S. Borenstein'>
<organization>First Virtual Holdings</organization>
<address>
<postal>
<street>25 Washington Avenue</street>
<city>Morristown</city>
<region>NJ</region>
<code>07960</code>
<country>US</country></postal>
<phone>+1 201 540 8967</phone>
<facsimile>+1 201 993 3032</facsimile>
<email>nsb@nsb.fv.com</email></address></author>
<date year='1996' month='November' />
<abstract>
<t>STD 11, RFC 822, defines a message representation protocol specifying considerable detail about US-ASCII message headers, and leaves the message content, or message body, as flat US-ASCII text.  This set of documents, collectively called the Multipurpose Internet Mail Extensions, or MIME, redefines the format of messages to allow for</t>
<t>(1)   textual message bodies in character sets other than US-ASCII,</t>
<t>(2)   an extensible set of different formats for non-textual message bodies,</t>
<t>(3)   multi-part message bodies, and</t>
<t>(4)   textual header information in character sets other than US-ASCII.</t>
<t>These documents are based on earlier work documented in RFC 934, STD 11, and RFC 1049, but extends and revises them.  Because RFC 822 said so little about message bodies, these documents are largely orthogonal to (rather than a revision of) RFC 822.</t>
<t>This initial document specifies the various headers used to describe the structure of MIME messages. The second document, RFC 2046, defines the general structure of the MIME media typing system and defines an initial set of media types. The third document, RFC 2047, describes extensions to RFC 822 to allow non-US-ASCII text data in Internet mail header fields. The fourth document, RFC 2048, specifies various IANA registration procedures for MIME-related facilities. The fifth and final document, RFC 2049, describes MIME conformance
  criteria as well as providing some illustrative examples of MIME message formats, acknowledgements, and the bibliography.</t>
<t>These documents are revisions of RFCs 1521, 1522, and 1590, which themselves were revisions of RFCs 1341 and 1342.  An appendix in RFC 2049 describes differences and changes from previous versions.</t></abstract></front>

<seriesInfo name='RFC' value='2045' />
<format type='TXT' octets='72932' target='http://www.rfc-editor.org/rfc/rfc2045.txt' />
</reference>



<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC6868'>

<front>
<title>Parameter Value Encoding in iCalendar and vCard</title>
<author initials='C.' surname='Daboo' fullname='C. Daboo'>
<organization /></author>
<date year='2013' month='February' />
<abstract>
<t>This specification updates the data formats for iCalendar (RFC 5545) and vCard (RFC 6350) to allow parameter values to include certain characters forbidden by the existing specifications.</t></abstract></front>

<seriesInfo name='RFC' value='6868' />
<format type='TXT' octets='11025' target='http://www.rfc-editor.org/rfc/rfc6868.txt' />
</reference>




    </references>



<section anchor="subtypes" title="Expected Subtypes">

<t>The following archive formats will be explored for registration as
subtypes along with this effort:</t>

<t><list style="hanging">
  <t hangText='Archiving Only'>
  TAR</t>
  <t hangText='Multipurpose (archiving, compression, encryption)'>
  ZIP, ACE, RAR, 7-Zip, StuffIt, FreeArc</t>
  <t hangText='Software Packaging'>
  MSI, RPM, JAR, XPI, CAB, CRX, APK</t>
  <t hangText='Disk Imaging'>
  ISO, NRG, BIN/CUE, VMDK, WIM, PartImage, IMG/IMA/IMZ, DMG</t>
</list></t>

</section>


  </back>
</rfc>

